{"id":"src/glsl/vertex.glsl","dependencies":[{"name":"/Users/mathilde/Desktop/audio-color-particles/package.json","includedInParent":true,"mtime":1733322456000}],"generated":{"js":"module.exports = \"#define GLSLIFY 1\\nvarying float vDistance;\\n\\nuniform float time;\\nuniform float offsetSize;\\nuniform float size;\\nuniform float offsetGain;\\nuniform float amplitude;\\nuniform float frequency;\\nuniform float maxDistance;\\n\\nvec3 mod289(vec3 x){\\n  return x-floor(x*(1./289.))*289.;\\n}\\n\\nvec2 mod289(vec2 x){\\n  return x-floor(x*(1./289.))*289.;\\n}\\n\\nvec3 permute(vec3 x){\\n  return mod289(((x*34.)+1.)*x);\\n}\\n\\nfloat noise(vec2 v) {\\n  const vec4 C=vec4(.211324865405187,.366025403784439,-.577350269189626,.024390243902439);// 1.0 / 41.0\\n  // First corner\\n  vec2 i=floor(v+dot(v,C.yy));\\n  vec2 x0=v-i+dot(i,C.xx);\\n  \\n  // Other corners\\n  vec2 i1;\\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\\n  //i1.y = 1.0 - i1.x;\\n  i1=(x0.x>x0.y)?vec2(1.,0.):vec2(0.,1.);\\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\\n  // x1 = x0 - i1 + 1.0 * C.xx ;\\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\\n  vec4 x12=x0.xyxy+C.xxzz;\\n  x12.xy-=i1;\\n  \\n  // Permutations\\n  i=mod289(i);// Avoid truncation effects in permutation\\n  vec3 p=permute(permute(i.y+vec3(0.,i1.y,1.))\\n  +i.x+vec3(0.,i1.x,1.));\\n  \\n  vec3 m=max(.5-vec3(dot(x0,x0),dot(x12.xy,x12.xy),dot(x12.zw,x12.zw)),0.);\\n  m=m*m;\\n  m=m*m;\\n  \\n  // Gradients: 41 points uniformly over a line, mapped onto a diamond.\\n  // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\\n  \\n  vec3 x=2.*fract(p*C.www)-1.;\\n  vec3 h=abs(x)-.5;\\n  vec3 ox=floor(x+.5);\\n  vec3 a0=x-ox;\\n  \\n  // Normalise gradients implicitly by scaling m\\n  // Approximation of: m *= inversesqrt( a0*a0 + h*h );\\n  m*=1.79284291400159-.85373472095314*(a0*a0+h*h);\\n  \\n  // Compute final noise value at P\\n  vec3 g;\\n  g.x=a0.x*x0.x+h.x*x0.y;\\n  g.yz=a0.yz*x12.xz+h.yz*x12.yw;\\n  return 130.*dot(m,g);\\n}\\n\\nvec3 curl(float x,float y,float z) {\\n  \\n  float eps=1.,eps2=2.*eps;\\n  float n1,n2,a,b;\\n  \\n  x+=time*.05;\\n  y+=time*.05;\\n  z+=time*.05;\\n  \\n  vec3 curl=vec3(0.);\\n  \\n  n1=noise(vec2(x,y+eps));\\n  n2=noise(vec2(x,y-eps));\\n  a=(n1-n2)/eps2;\\n  \\n  n1=noise(vec2(x,z+eps));\\n  n2=noise(vec2(x,z-eps));\\n  b=(n1-n2)/eps2;\\n  \\n  curl.x=a-b;\\n  \\n  n1=noise(vec2(y,z+eps));\\n  n2=noise(vec2(y,z-eps));\\n  a=(n1-n2)/eps2;\\n  \\n  n1=noise(vec2(x+eps,z));\\n  n2=noise(vec2(x+eps,z));\\n  b=(n1-n2)/eps2;\\n  \\n  curl.y=a-b;\\n  \\n  n1=noise(vec2(x+eps,y));\\n  n2=noise(vec2(x-eps,y));\\n  a=(n1-n2)/eps2;\\n  \\n  n1=noise(vec2(y+eps,z));\\n  n2=noise(vec2(y-eps,z));\\n  b=(n1-n2)/eps2;\\n  \\n  curl.z=a-b;\\n  \\n  return curl;\\n}\\n\\nvoid main() {\\n  vec3 newpos = position;\\n  vec3 target = position + (normal*.1) + curl(newpos.x * frequency, newpos.y * frequency, newpos.z * frequency) * amplitude;\\n  \\n  float d = length(newpos - target) / maxDistance;\\n  newpos = mix(position, target, pow(d, 4.));\\n  newpos.z += sin(time) * (.1 * offsetGain);\\n  \\n  vec4 mvPosition = modelViewMatrix * vec4(newpos, 1.);\\n  gl_PointSize = size + (pow(d,3.) * offsetSize) * (1./-mvPosition.z);\\n  gl_Position = projectionMatrix * mvPosition;\\n  \\n  vDistance = d;\\n}\";"},"sourceMaps":{"js":{"mappings":[{"generated":{"line":1,"column":0},"source":"src/glsl/vertex.glsl","original":{"line":1,"column":0},"name":"module"},{"generated":{"line":1,"column":6},"source":"src/glsl/vertex.glsl","original":{"line":1,"column":6}},{"generated":{"line":1,"column":7},"source":"src/glsl/vertex.glsl","original":{"line":1,"column":7},"name":"exports"},{"generated":{"line":1,"column":14},"source":"src/glsl/vertex.glsl","original":{"line":1,"column":14}},{"generated":{"line":1,"column":17},"source":"src/glsl/vertex.glsl","original":{"line":1,"column":15}},{"generated":{"line":1,"column":3009},"source":"src/glsl/vertex.glsl","original":{"line":1,"column":3007}}],"sources":{"src/glsl/vertex.glsl":"module.exports=\"#define GLSLIFY 1\\nvarying float vDistance;\\n\\nuniform float time;\\nuniform float offsetSize;\\nuniform float size;\\nuniform float offsetGain;\\nuniform float amplitude;\\nuniform float frequency;\\nuniform float maxDistance;\\n\\nvec3 mod289(vec3 x){\\n  return x-floor(x*(1./289.))*289.;\\n}\\n\\nvec2 mod289(vec2 x){\\n  return x-floor(x*(1./289.))*289.;\\n}\\n\\nvec3 permute(vec3 x){\\n  return mod289(((x*34.)+1.)*x);\\n}\\n\\nfloat noise(vec2 v) {\\n  const vec4 C=vec4(.211324865405187,.366025403784439,-.577350269189626,.024390243902439);// 1.0 / 41.0\\n  // First corner\\n  vec2 i=floor(v+dot(v,C.yy));\\n  vec2 x0=v-i+dot(i,C.xx);\\n  \\n  // Other corners\\n  vec2 i1;\\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\\n  //i1.y = 1.0 - i1.x;\\n  i1=(x0.x>x0.y)?vec2(1.,0.):vec2(0.,1.);\\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\\n  // x1 = x0 - i1 + 1.0 * C.xx ;\\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\\n  vec4 x12=x0.xyxy+C.xxzz;\\n  x12.xy-=i1;\\n  \\n  // Permutations\\n  i=mod289(i);// Avoid truncation effects in permutation\\n  vec3 p=permute(permute(i.y+vec3(0.,i1.y,1.))\\n  +i.x+vec3(0.,i1.x,1.));\\n  \\n  vec3 m=max(.5-vec3(dot(x0,x0),dot(x12.xy,x12.xy),dot(x12.zw,x12.zw)),0.);\\n  m=m*m;\\n  m=m*m;\\n  \\n  // Gradients: 41 points uniformly over a line, mapped onto a diamond.\\n  // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\\n  \\n  vec3 x=2.*fract(p*C.www)-1.;\\n  vec3 h=abs(x)-.5;\\n  vec3 ox=floor(x+.5);\\n  vec3 a0=x-ox;\\n  \\n  // Normalise gradients implicitly by scaling m\\n  // Approximation of: m *= inversesqrt( a0*a0 + h*h );\\n  m*=1.79284291400159-.85373472095314*(a0*a0+h*h);\\n  \\n  // Compute final noise value at P\\n  vec3 g;\\n  g.x=a0.x*x0.x+h.x*x0.y;\\n  g.yz=a0.yz*x12.xz+h.yz*x12.yw;\\n  return 130.*dot(m,g);\\n}\\n\\nvec3 curl(float x,float y,float z) {\\n  \\n  float eps=1.,eps2=2.*eps;\\n  float n1,n2,a,b;\\n  \\n  x+=time*.05;\\n  y+=time*.05;\\n  z+=time*.05;\\n  \\n  vec3 curl=vec3(0.);\\n  \\n  n1=noise(vec2(x,y+eps));\\n  n2=noise(vec2(x,y-eps));\\n  a=(n1-n2)/eps2;\\n  \\n  n1=noise(vec2(x,z+eps));\\n  n2=noise(vec2(x,z-eps));\\n  b=(n1-n2)/eps2;\\n  \\n  curl.x=a-b;\\n  \\n  n1=noise(vec2(y,z+eps));\\n  n2=noise(vec2(y,z-eps));\\n  a=(n1-n2)/eps2;\\n  \\n  n1=noise(vec2(x+eps,z));\\n  n2=noise(vec2(x+eps,z));\\n  b=(n1-n2)/eps2;\\n  \\n  curl.y=a-b;\\n  \\n  n1=noise(vec2(x+eps,y));\\n  n2=noise(vec2(x-eps,y));\\n  a=(n1-n2)/eps2;\\n  \\n  n1=noise(vec2(y+eps,z));\\n  n2=noise(vec2(y-eps,z));\\n  b=(n1-n2)/eps2;\\n  \\n  curl.z=a-b;\\n  \\n  return curl;\\n}\\n\\nvoid main() {\\n  vec3 newpos = position;\\n  vec3 target = position + (normal*.1) + curl(newpos.x * frequency, newpos.y * frequency, newpos.z * frequency) * amplitude;\\n  \\n  float d = length(newpos - target) / maxDistance;\\n  newpos = mix(position, target, pow(d, 4.));\\n  newpos.z += sin(time) * (.1 * offsetGain);\\n  \\n  vec4 mvPosition = modelViewMatrix * vec4(newpos, 1.);\\n  gl_PointSize = size + (pow(d,3.) * offsetSize) * (1./-mvPosition.z);\\n  gl_Position = projectionMatrix * mvPosition;\\n  \\n  vDistance = d;\\n}\";"},"lineCount":null}},"error":null,"hash":"f25483838c57fd8fde06f2a3a5b62c84","cacheData":{"env":{}}}